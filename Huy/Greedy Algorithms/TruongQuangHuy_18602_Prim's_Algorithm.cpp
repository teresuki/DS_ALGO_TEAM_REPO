// Minimum spanning tree by Prim Algorithm -- a problem that exhibit greedy property (and optimal structure)
// With a lot of advanced features from C++ STL
/* Name: Truong Quang Huy
   ID: 18602
   Class: CS2019 - VGU
*/

#include <iostream>
#include <vector>
#include <utility>
#include <algorithm>
#include <climits>
#include <map>
using namespace std;
typedef int key;
typedef int vertex;


// Driver function to sort the vector elements
// by second element of pairs in descending order
/* a kind of function pointer, use frequently in sorting */
bool sort_by_second(const pair<vertex, key>& a, const pair<vertex, key>& b)
{
    return (a.second > b.second);
}

map<int, char> vertex_name = {{0, 'a'}, {1, 'b'}, {2, 'c'}, {3, 'd'},
                              {4, 'e'}, {5, 'f'}, {6, 'g'}, {7, 'h'}};
enum vertices {a, b, c, d, e, f, g, h};
int graph_1[8][8] = {
    {0, 12, 5, 4, 0, 0, 0, 0},
    {12, 0, 9, 11, 0, 0, 0, 0},
    {5, 9, 0, 2, 2, 4, 0, 0},
    {0, 11, 2, 0, 7, 0, 1, 0},
    {0, 0, 2, 7, 0, 0, 3, 6},
    {0, 0, 4, 0, 0, 0, 8, 1},
    {0, 0, 0, 1, 3, 8, 0, 0},
    {0, 0, 0, 0, 6, 1, 0, 0}
};

vector<int> Prim_MST(int graph[8][8])  // r = a
{
    vector<int> p(8, -1);

    /* quick, "cheap" code for easy implementation with a lot of unnecessary sorting
       should use priority queue for better performance */
    vector<pair<vertex, key>> Q = {{a, 0}      , {b, INT_MAX}, {c, INT_MAX}, {d, INT_MAX},
                                   {e, INT_MAX}, {f, INT_MAX}, {g, INT_MAX}, {h, INT_MAX}};

    while(Q.size() != 0)
    {
        sort(Q.begin(), Q.end(), sort_by_second);   // Max Priority Queue for easier implementation

        pair<vertex, key> get_u = Q.back();   // equal to
        Q.pop_back();                         // ExtractMin(Q)

        int u = get_u.first;  // get the position of u in the adjacency matrix
        for(int v = 0; v < 8; v++)
        {
            if(graph[u][v] != 0)   // for each v adjacent to u
            {
                auto v_position_in_Q = find_if(Q.begin(), Q.end(),  /* it's magic named "lambda" */
                                    [&v](const pair<vertex, key>& element){ return element.first == v;});
                if(v_position_in_Q != Q.end())    // if v belong to Q
                {
                    if(graph[u][v] < (*v_position_in_Q).second) // be already an iterator, just need dereference
                    {
                        p[v] = u;
                        (*v_position_in_Q).second = graph[u][v];
                    }
                }
            }
        }
        // break;// -- jump out of the loop no matter what, good to check the logic
    }

    return p;
}

int main(void)
{
    vector<int> result = Prim_MST(graph_1);

    cout << "The graph represented by adjacency matrix: " << endl;
    for(int i = 0; i < 8; i++)
    {
        for(int j = 0; j < 8; j++)
            printf("%3d", graph_1[i][j]);
        cout << endl;
    }

    cout << "\nThe minimum spanning tree generated by Prim's algorithm:" << endl;
    cout << "V[] = ";
    for(auto itr = vertex_name.begin(); itr != vertex_name.end(); itr++)
        printf("%3c", itr->second);

    cout << "\np[] = nil";
    for(size_t i = 1; i < result.size(); i++)
        printf("%3c", vertex_name[result[i]]);

    cout << endl;

    return 0;
}
